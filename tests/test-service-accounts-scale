#!/usr/bin/env bash
set -euo pipefail

N=4
SIZE="pulse"
FLOCK_SIZE=1
VERBOSE=false
while [[ $# -gt 0 ]]; do
  case $1 in
    --n) N="$2"; shift 2 ;;
    --size) SIZE="$2"; shift 2 ;;
    --flock-size) FLOCK_SIZE="$2"; shift 2 ;;
    -v|--verbose) VERBOSE=true; shift ;;
    *) echo "Unknown option: $1"; exit 1 ;;
  esac
done

RUN_ID=$(date +%s)
RUN_DATE=$(date +%Y-%m-%dT%H:%M:%S)
LOGS_DIR="./logs/${RUN_DATE}"
mkdir -p "$LOGS_DIR"
PIDS=()
FAILURES=0

log() {
  [[ "$VERBOSE" == true ]] || return 0
  local i=$1; shift
  printf "[worker %3d] %s\n" "$i" "$*"
}

worker() {
  local i=$1
  local sa_name="scale_${RUN_ID}_${i}"
  local log_file="${LOGS_DIR}/${i}.json"
  local start_ns end_ns
  local step_create_sa step_set_duckling step_create_token step_select1 step_select2 step_select3 step_pragma step_cleanup
  local status="success"
  local error=""
  local token=""

  start_ns=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")

  # Create service account
  log "$i" "creating service account: $sa_name"
  local t0=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  if ! md service-account create "$sa_name" >/dev/null 2>&1; then
    status="failed"; error="create service account failed"
    log "$i" "FAILED: $error"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "" "" "" "" "" "" "" ""
    return 1
  fi
  local t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_create_sa=$(( (t1 - t0) / 1000000 ))
  log "$i" "service account created (${step_create_sa}ms)"

  # Set duckling config
  t0=$t1
  if ! md duckling set --rw-size "$SIZE" --rs-size "$SIZE" --flock-size "$FLOCK_SIZE" "$sa_name" >/dev/null 2>&1; then
    status="failed"; error="set duckling config failed"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "" "" "" "" "" "" ""
    return 1
  fi
  t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_set_duckling=$(( (t1 - t0) / 1000000 ))
  log "$i" "duckling config set (${step_set_duckling}ms)"

  # Create token
  t0=$t1
  local token_json
  if ! token_json=$(md token create -o json --name "scale_test" "$sa_name" 2>&1); then
    status="failed"; error="create token failed"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "$step_set_duckling" "" "" "" "" "" ""
    return 1
  fi
  token=$(echo "$token_json" | jq -r '.token')
  if [[ -z "$token" || "$token" == "null" ]]; then
    status="failed"; error="token parse failed"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "$step_set_duckling" "" "" "" "" "" ""
    return 1
  fi
  t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_create_token=$(( (t1 - t0) / 1000000 ))
  log "$i" "token created (${step_create_token}ms): $token"

  # Run SELECT 1 (cold)
  t0=$t1
  local select_output
  if ! select_output=$(MOTHERDUCK_TOKEN="$token" duckdb md: "SELECT 1;" 2>&1); then
    status="failed"; error="SELECT 1 failed: $(echo "$select_output" | head -1)"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "$step_set_duckling" "$step_create_token" "" "" "" "" ""
    return 1
  fi
  t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_select1=$(( (t1 - t0) / 1000000 ))
  log "$i" "SELECT 1 cold (${step_select1}ms)"

  # Run SELECT 2 (warm)
  t0=$t1
  if ! select_output=$(MOTHERDUCK_TOKEN="$token" duckdb md: "SELECT 2;" 2>&1); then
    status="failed"; error="SELECT 2 failed: $(echo "$select_output" | head -1)"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "$step_set_duckling" "$step_create_token" "$step_select1" "" "" "" ""
    return 1
  fi
  t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_select2=$(( (t1 - t0) / 1000000 ))
  log "$i" "SELECT 2 warm (${step_select2}ms)"

  # Run SELECT 3 (hot)
  t0=$t1
  if ! select_output=$(MOTHERDUCK_TOKEN="$token" duckdb md: "SELECT 3;" 2>&1); then
    status="failed"; error="SELECT 3 failed: $(echo "$select_output" | head -1)"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "$step_set_duckling" "$step_create_token" "$step_select1" "$step_select2" "" "" ""
    return 1
  fi
  t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_select3=$(( (t1 - t0) / 1000000 ))
  log "$i" "SELECT 3 hot (${step_select3}ms)"

  # Run pragma print_md_token and verify
  t0=$t1
  local pragma_output
  if ! pragma_output=$(MOTHERDUCK_TOKEN="$token" duckdb md: "PRAGMA print_md_token;" 2>&1); then
    status="failed"; error="pragma print_md_token failed: $(echo "$pragma_output" | head -1)"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "$step_set_duckling" "$step_create_token" "$step_select1" "$step_select2" "$step_select3" "" ""
    return 1
  fi
  # Extract token from pragma output (format: "export motherduck_token=<token>\n<table>")
  local pragma_token
  pragma_token=$(echo "$pragma_output" | grep -i 'motherduck_token=' | sed 's/.*motherduck_token=//' | tr -d '[:space:]')
  if [[ "$pragma_token" != "$token" ]]; then
    status="failed"; error="token mismatch: pragma returned '${pragma_token}' expected '${token}'"
    log "$i" "FAILED: $error"
    log "$i" "service account left intact: $sa_name"
    write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" "$step_create_sa" "$step_set_duckling" "$step_create_token" "$step_select1" "$step_select2" "$step_select3" "" ""
    return 1
  fi
  t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_pragma=$(( (t1 - t0) / 1000000 ))
  log "$i" "pragma token verified (${step_pragma}ms): $pragma_token"

  # Cleanup
  t0=$t1
  cleanup "$sa_name"
  t1=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  step_cleanup=$(( (t1 - t0) / 1000000 ))
  log "$i" "cleaned up (${step_cleanup}ms)"

  end_ns=$t1
  local total_ms=$(( (end_ns - start_ns) / 1000000 ))
  log "$i" "DONE (${total_ms}ms total)"

  write_log "$log_file" "$i" "$sa_name" "$start_ns" "$status" "$error" \
    "$step_create_sa" "$step_set_duckling" "$step_create_token" "$step_select1" "$step_select2" "$step_select3" "$step_pragma" "$step_cleanup"
}

cleanup() {
  md service-account delete "$1" >/dev/null 2>&1 || true
}

json_escape() {
  jq -n --arg s "$1" '$s'
}

write_log() {
  local file=$1 idx=$2 sa=$3 start_ns=$4 status=$5 error=$6
  local t_create=${7:-""} t_duckling=${8:-""} t_token=${9:-""} t_select1=${10:-""} t_select2=${11:-""} t_select3=${12:-""} t_pragma=${13:-""} t_cleanup=${14:-""}

  local end_ns
  end_ns=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
  local total_ms=$(( (end_ns - start_ns) / 1000000 ))

  local escaped_error
  escaped_error=$(json_escape "$error")

  cat > "$file" <<EOJSON
{
  "worker": $idx,
  "service_account": "$sa",
  "run_id": $RUN_ID,
  "status": "$status",
  "error": $escaped_error,
  "total_ms": $total_ms,
  "create_sa_ms": ${t_create:-null},
  "set_duckling_ms": ${t_duckling:-null},
  "create_token_ms": ${t_token:-null},
  "select1_ms": ${t_select1:-null},
  "select2_ms": ${t_select2:-null},
  "select3_ms": ${t_select3:-null},
  "pragma_ms": ${t_pragma:-null},
  "cleanup_ms": ${t_cleanup:-null}
}
EOJSON
}

echo "=== Scale test: N=$N, size=$SIZE, flock=$FLOCK_SIZE, run=$RUN_ID ==="

for i in $(seq 0 $((N - 1))); do
  worker "$i" &
  PIDS+=($!)
done

echo "Launched $N workers, waiting..."

for pid in "${PIDS[@]}"; do
  wait "$pid" || ((FAILURES++))
done

echo ""
echo "=== Results ==="
echo "Total: $N | Failed: $FAILURES | Passed: $((N - FAILURES))"

# Summary via duckdb
echo ""
echo "=== Timing summary ==="
duckdb -c "
SELECT
  count(*) as n,
  count(*) FILTER (status = 'success') as passed,
  count(*) FILTER (status = 'failed') as failed,
  round(avg(total_ms), 0) as avg_total_ms,
  round(min(total_ms), 0) as min_total_ms,
  round(max(total_ms), 0) as max_total_ms,
  round(quantile_cont(total_ms, 0.5), 0) as p50_ms,
  round(quantile_cont(total_ms, 0.95), 0) as p95_ms,
  round(avg(create_sa_ms), 0) as avg_create_sa_ms,
  round(avg(set_duckling_ms), 0) as avg_set_duckling_ms,
  round(avg(create_token_ms), 0) as avg_create_token_ms,
  round(avg(select1_ms), 0) as avg_select1_ms,
  round(avg(select2_ms), 0) as avg_select2_ms,
  round(avg(select3_ms), 0) as avg_select3_ms,
  round(avg(pragma_ms), 0) as avg_pragma_ms,
  round(avg(cleanup_ms), 0) as avg_cleanup_ms
FROM read_json_auto('${LOGS_DIR}/*.json');
"

if [[ "$FAILURES" -gt 0 ]]; then
  echo ""
  echo "=== Failed service accounts (not deleted) ==="
  duckdb -c "
  SELECT service_account, error
  FROM read_json_auto('${LOGS_DIR}/*.json')
  WHERE status = 'failed' AND create_sa_ms IS NOT NULL
  ORDER BY worker;
  "
  echo ""
  echo "To clean up: md service-account delete <name>"
fi

echo ""
echo "Logs: ${LOGS_DIR}/*.json"
echo "Query this run:  duckdb -c \"SELECT * FROM read_json_auto('${LOGS_DIR}/*.json') ORDER BY worker;\""
echo "Query all runs:  duckdb -c \"SELECT * FROM read_json_auto('./logs/**/*.json') ORDER BY run_id, worker;\""
